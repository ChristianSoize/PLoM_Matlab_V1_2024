
function  [MatRg] = sub_projection_basis_isotropic_kernel(nu,n_d,MatReta_d,mDP,nbmDMAP,epsilonDIFFmin,step_epsilonDIFF, ...
                    iterlimit,comp_ref,ind_display_screen,ind_print,ind_plot) 

   %------------------------------------------------------------------------------------------------------------------------------------------
   %
   %  Copyright: Christian Soize, Universite Gustave Eiffel, 2 June 2024
   %
   %  Software     : Probabilistic Learning on Manifolds (PLoM) 
   %  Function name: sub_projection_basis_isotropic_kernel.m
   %  Subject      : for ind_basis_type == 2, generating matrix MatRg(n_d,nbmDMAP) of the nbmDMAP projection basis vectors
   %                 solving the eigenvalue problem related to the isotropic kernel
   %
   %  Publications: [1] C. Soize, R. Ghanem, Data-driven probability concentration and sampling on manifold, 
   %                       Journal of Computational Physics,  doi:10.1016/j.jcp.2016.05.044, 321, 242-258 (2016).
   %                [2] C. Soize, R. Ghanem, Probabilistic learning on manifolds, Foundations of Data Science, 
   %                       American  Institute of Mathematical Sciences (AIMS),  doi: 10.3934/fods.2020013, 2(3), 279-307 (2020). .
   %                [3] C. Soize, R. Ghanem, Probabilistic learning on manifolds (PLoM) with partition, International Journal for 
   %                       Numerical Methods in Engineering, doi: 10.1002/nme.6856, 123(1), 268-290 (2022).
   %
   %--- INPUTS 
   %        nu                  : dimension of random vector H = (H_1, ... H_nu)
   %        n_d                 : number of points in the training set for H
   %        MatReta_d(nu,n_d)   : n_d realizations of H 
   %        mDP                 : maximum number of projection-basis vectors that are generated by the isotropic kernel
   %                              with nbmDMAP <= mDP <= n_d
   %        nbmDMAP             : dimension of the projection basis such that nbmDMAP <= mDP   %                            
   %                            --- if ind_basis_type = 2, then the following parameters are required for generating
   %                                   the projection basis by solving the eigenvalue problem related to the isotropic kernel:
   %                                   the smooting paramameter epsilonDIFF   is serached with an iteration algorithm              
   %        epsilonDIFFmin         :   epsilonDIFF is searched in interval [epsilonDIFFmin , +infty[                                    
   %        step_epsilonDIFF       :   step for searching the optimal value epsilonDIFF starting from epsilonDIFFmin
   %        iterlimit              :   maximum number of the iteration algorithm for computing epsilonDIFF                              
   %        comp_ref               :   value in  [ 0.1 , 0.5 [  used for stopping the iteration algorithm.
   %                                   if comp =  Rlambda(nbmDMAP+1)/Rlambda(nbmDMAP) <= comp_ref, then algorithm is stopped
   %                                   The standard value for comp_ref is 0.1 
   %                            --- parameters and variables controling execution
   %        ind_display_screen  : 0, no display, if 1 display
   %        ind_print           : 0, no print, if 1 print
   %        ind_plot            : 0, no plot, if  1 plot
   %        ind_parallel        : 0, no parallel computation, if 1 parallel computation
   %
   %--- OUTPUTS
   %        MatRg(n_d,nbmDMAP)  : matrix of the projection basis
    
   numfig = 0;

   %--- Constructing the column matrix contraining the iterlimit values of epsilonDIFF 
   RepsilonDIFF = zeros(iterlimit,1);
   for iter = 1:iterlimit
       RepsilonDIFF(iter) = epsilonDIFFmin + step_epsilonDIFF*(iter-1);
   end
    
   %--- Finding the optimal value epsilonDIFF by solving the iteration algorithm
   Rcomp = zeros(iterlimit,1);                                           % Rcomp(iterlimit,1)
   for iter = 1:iterlimit
       % Display
       if ind_display_screen == 1
          disp(['  iter = ',num2str(iter)])
       end
       epsilonDIFF_iter = RepsilonDIFF(iter);
       
       % Isotropic kernel, computing MatRKernel_iter(n_d,n_d) 
       co_iter = 1/(4*epsilonDIFF_iter);  
       MatRtemp1 = zeros(n_d,n_d);
       for j=1:n_d
           MatRtemp2 = zeros(nu,n_d);
           for k=1:nu
               MatRtemp2(k,:) = (MatReta_d(k,:) - MatReta_d(k,j)).^2;    % MatRtemp2(nu,n_d),MatReta_d(nu,n_d)               
           end 
           MatRtemp1(j,:) = sum(MatRtemp2,1);                            % MatRtemp1(n_d,n_d)
       end
       MatRKernel_temp = exp(-co_iter*MatRtemp1);                        % MatRKernel_temp(n_d,n_d) 
       
       % Removing the negative zeros of the eigenvalues of MatRKernel_temp
       scaling         = max(max(MatRKernel_temp));                                       
       MatRKernel_iter = MatRKernel_temp + scaling*1e-12*eye(n_d,n_d);   % MatRKernel_iter(n_d,n_d) 
    
       % Computing the transition probability matrix MatRPs       
       MatRPs_iter = zeros(n_d,n_d);                                     % MatRPs_iter(n_d,n_d)
       Rd          = sum(MatRKernel_iter,2);                             % Rd(n_d,1),MatRKernel_iter(n_d,n_d) 
       Rdm1s2      = 1./sqrt(Rd);                                        % Rdm1s2(n_d,1)
       for i=1:n_d
           MatRPs_iter(i,:) = Rdm1s2(i)*MatRKernel_iter(i,:).*Rdm1s2';   % MatRPs_iter(n_d,n_d), Symmetric matrix
       end
       MatRPs_iter = 0.5*(MatRPs_iter + MatRPs_iter');                   % MatRPs_iter(n_d,n_d), imposing a perfect symmetry

       % Computing the eigenvalues of  MatRPs_iter * MatRphi_iter = MatRphi_iter * diag(Rlambda_iter) 
       [MatRphi1,MatRdiag] = eig(MatRPs_iter);                           % MatRPs_iter(n_d,n_d)
       Rlambda1            = diag(MatRdiag);                             % Rlambda1(n_d,1)
       [~,Index]           = sort(Rlambda1,'descend');                   % descending order
       Rlambda_iter        = Rlambda1(Index);                            % Rlambda_iter(n_d,1) 
       MatRphi_iter        = MatRphi1(:,Index);                          % MatRphi_iter(n_d,n_d)

       %--- checking the jump in the eigenvalues spectrum with comp = Rlambda_iter(nbmDMAP+1)/Rlambda_iter(nbmDMAP)<= comp_ref 
       %    given by the user in [ 0.1 , 0.5 [
       comp_iter = Rlambda_iter(nbmDMAP+1)/Rlambda_iter(nbmDMAP);
       Rcomp(iter,1) = comp_iter;                                        % Rcomp(iterlimit,1)                                  
       if comp_iter <= comp_ref                                          % solution is epsilonDIFF
          epsilonDIFF = epsilonDIFF_iter;
          iter_conv   = iter;
          break
       end  
       
       %--- no convergence
       if iter == iterlimit  
          % Plot
          if ind_plot == 1
             h = figure; 
             plot((1:iterlimit)',Rcomp(1:iterlimit),'b-o')
             title('Graph iter $\mapsto$ Rcomp(iter)','FontSize',16,'Interpreter','latex','FontWeight','normal');
             xlabel('iter','FontSize',16,'Interpreter','latex') 
             ylabel('Rcomp(iter)','FontSize',16,'Interpreter','latex') 
             numfig = numfig + 1;
             saveas(h,['figure_isotropic_kernel_basis_',num2str(numfig),'_Rcomp.fig']); 
             close(h);
          end
          
          % Display
          disp('STOP in sub_projection_basis_isotropic_kernel: iterlimit reached without finding a solution')
          
          % Print
          fidlisting = fopen('listing.txt','a+'); 
          fprintf(fidlisting,'      \n '); 
          fprintf(fidlisting,'STOP in sub_projection_basis_isotropic_kernel: iterlimit reached without finding a solution'); 
          fclose(fidlisting);  

          error('STOP in sub_projection_basis_isotropic_kernel: iterlimit reached without finding a solution')
       end
   end       % end loop iter 
   
   %--- Convergence is reached
   Rlambda = Rlambda_iter(1:mDP);    % Rlambda(mDP,1),Rlambda_iter(n_d,1)  
   MatRphi = MatRphi_iter(:,1:mDP);  % MatRphi(n_d,mDP),MatRphi_iter(n_d,n_d)
   MatRg_mDP = zeros(n_d,mDP);       % MatRg_mDP(n_d,mDP);                         
   for beta = 1:mDP
       MatRg_mDP(:,beta) = MatRphi(:,beta).*Rdm1s2;        
   end 
   clear MatRphi

   %--- Loading the nbmDMAP projection basis vectors (diffusion maps)
   MatRg = MatRg_mDP(:,1:nbmDMAP);              % MatRg(n_d,nbmDMAP),MatRg_mDP(n_d,mDP) 
  
   %--- Plot
   if ind_plot == 1
      if iterlimit - iter_conv >= 1
         iter_plot = iter_conv + 1;
      end
      h = figure; 
      plot((1:iter_plot)',Rcomp(1:iter_plot),'b-o')
      title('Graph iter $\mapsto$ Rcomp(iter)','FontSize',16,'Interpreter','latex','FontWeight','normal');
      xlabel('iter','FontSize',16,'Interpreter','latex') 
      ylabel('Rcomp(iter)','FontSize',16,'Interpreter','latex') 
      numfig = numfig + 1;
      saveas(h,['figure_isotropic_kernel_basis_',num2str(numfig),'_Rcomp.fig']); 
      close(h);

      h=figure;                                
      semilogy((1:mDP)',Rlambda(1:mDP),'-o') 
      title(['Eigenvalues $\alpha\mapsto\lambda_\alpha$ of the transition matrix'], ...
              'FontSize',16,'Interpreter','latex','FontWeight','normal');                                        
      xlabel('$\alpha$','FontSize',16,'Interpreter','latex');                                                                
      ylabel('$\lambda_\alpha$','FontSize',16,'Interpreter','latex');
      numfig = numfig + 1;
      saveas(h,['figure_isotropic_kernel_basis_',num2str(numfig),'_eigenvalueDMAPS.fig']); 
      close(h)    
   end

   %--- Print
   if ind_print == 1
      fidlisting=fopen('listing.txt','a+');  
      fprintf(fidlisting,'                                              \n '); 
      fprintf(fidlisting,' ----- sub_projection_basis_isotropic_kernel: construction of the DMAPS basis for the isotropic kernel \n ');                        
      fprintf(fidlisting,'               \n '); 
      fprintf(fidlisting,'      \n '); 
      fprintf(fidlisting,' n_d              = %7i \n ',n_d); 
      fprintf(fidlisting,' mDP              = %7i \n ',mDP); 
      fprintf(fidlisting,' nbmDMAP          = %7i \n ',nbmDMAP); 
      fprintf(fidlisting,'               \n ');
      fprintf(fidlisting,' epsilonDIFFmin   = %14.7e \n ',epsilonDIFFmin); 
      fprintf(fidlisting,' step_epsilonDIFF = %14.7e \n ',step_epsilonDIFF); 
      fprintf(fidlisting,' epsilonDIFF      = %14.7e \n ',epsilonDIFF); 
      fprintf(fidlisting,'      \n '); 
      fprintf(fidlisting,' eigenvalues of the transition matrix \n ');                        
      fprintf(fidlisting,'               \n '); 
      Rnum      = (1:mDP)'; 
      MatRprint = [Rnum Rlambda(1:mDP)]';                                        
      fprintf(fidlisting,' %5i %18.11e  \n ',MatRprint);  
      fclose(fidlisting); 
   end
   return
end
 
   


 

 